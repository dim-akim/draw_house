Описание версий (этапов создания) сервера на Flask:

step_1
    server:
        Простой сервер на Flask

step_2
    server:
        + функция представления index возвращает HTML-код по адресу /index

step_3
    + templates/:
        используем архив "Сайт начинающего верстальщика" из курса "Основы HTML" на HTMLAcademy
        надо настроить PyCharm, чтобы видел папку templates, как папку с шаблонами
        ПРОБЛЕМА: не подгружаются файлы .css и картинки (решаем на шаге 4)
    server:
        + в функции hello вставляем ссылку на адрес /index для удобства
        + импорт функции render_template
        + функция index теперь возвращает результат вызова функции render_template
        + первым параметром функции render_template должен быть index.html из папки templates

step_3.1
    Шаблон называется так, потому что туда можно подставлять какие-то дополнительные значения, вычисленные в функции представления
    Во Flask используется язык Jinja2
    Можно включить его поддержку в настройках (Languages and Frameworks -> Template Languages)
    templates/index:
        + На строке 11 в заголовке добавляем {{ nickname }} - сюда встанет значение из функции
    server:
        + словарь {'nickname': 'dim-akim'} (вместо dim-akim можно подставить любое имя или ник)
        + при вызове render_template можно передавать именованные параметры, которые будут подставляться
          в соответствующие места в шаблоне

step_4 - папка static
    + static/:
        по структуре Flask все статичные файлы должны храниться в папке static
        туда надо перенести файл стилей (style.css) и папки с картинками и файлами (/img и /files)
        надо настроить PyCharm, чтобы видел папку static, как папку-источник
    templates/index:
        Ссылка на файл стилей href="style.css" - относительная, на поиск файла в том же каталоге.
        + Корректируем ссылку на файл стилей (6 строка): style.css -> static/style.css
        + Корректируем ссылку на аватарку (13 строка): img/raccoon.svg -> static/img/raccoon.svg
        ПРОБЛЕМА: не работают ссылки на другие страницы (решаем на шаге 5)

step_5 - путь с использованием переменной
    server:
        + декоратор пути с использованием переменной - /day-<num>
        + функция представления day(num), которая возвращает отрисованный шаблон day-{num}.html
    templates/index:
        + корректируем ссылки на внутренние страницы, убираем .html
        ПРОВЕРКА: пройти по всем измененным ссылкам
    templates/*:
        + (Из шага 4) Корректируем ссылки на все статичные файлы, добавляя к ссылке префикс static/

step_5.1
    server:
        + декоратор пути с использованием переменной - /photo-<num>
        + функция представления day(num), которая возвращает отрисованный шаблон photo-{num}.html
    templates/day-15:
        + корректируем ссылки на внутренние страницы, убираем .html
        ПРОВЕРКА: пройти по всем ссылкам и убедиться, что они работают

step_6 - функция url_for
    Если адрес главной страницы (/index) изменится (например, на /blog/index), то ссылка на в функции hello перестанет работать
    Чтобы этого избежать, во Flask есть функция url_for
    server:
        + дополнительно импортируем функцию url_for из пакета flask
        + в функции hello заменяем простую ссылку (href="/index") на href="{url_for('index')}" (используем f-строку)
        ПРОВЕРКА: изменить адрес в декораторе функции index и убедиться, что ссылка каждый раз работает
        ПРОБЛЕМА: при изменении адреса в декораторе функции index может перестать работать ссылка на файл стилей. Решается далее

    Функцию url_for можно использовать не только в файлах .py, но и в шаблонах
    {{ url_for('index') }} - ссылка на функцию представления index
    {{ url_for('day', num=1) }} - ссылка на функцию представления day(num) с переменной num = 1
    {{ url_for('static', filename='style.css' }} - ссылка на статичный файл / ресурс, который лежит в папке static
    templates/index:
        + Корректируем ссылку на файл стилей (6 строка): static/style.css -> {{ url_for('static', filename='style.css' }}
        + Корректируем ссылку на аватарку (13 строка): static/img/raccoon.svg -> {{ url_for('static', filename='img/raccoon.svg' }}
        + Корректируем ссылки на дни (17-31 строки): day-1 -> {{ url_for('day', num=1) }} и т.п.
    templates/*
        + Корректируем все ссылки на другие страницы и на статичные файлы
    templates/day-15
        ОСОБОЕ внимание ссылкам на фото

step_7 - выделение базового шаблона
    Мощность шаблонизатора заключается в том, что повторяющиеся куски разных страниц можно выделить в отдельный шаблон,
    а в остальных файлах не описывать всю страницу целиком, а только изменяющуюся часть.
    Выделяем из index.html шаблон базовой страницы
    + templates/base.html:
        + скопировать сюда содержимое файла index.html
        перенести аватарку <img class="avatar" ...> из тега main в тег header
        - удалить все, что находится внутри тега main (должны остаться только открывающий и закрывающий теги <main></main>)
        + {% block content %}{% endblock %} внутри тега main
    + templates/start.html:
        + расширяет шаблон base.html
        + переопределяет блок content
        + скопировать в блок content из файла index.html все содержимое тега main, кроме аватарки <img class="avatar" ...>
    server:
        + декоратор пути /base
        + функция start, которая возвращает отрисованный шаблон base.html
        + декоратор пути /start
        + функция start, которая возвращает отрисованный шаблон start.html
        + в функции hello добавляем ссылки на эндпоинты функций start и base с помощью url_for
        ПРОВЕРКА: поочередно нажимаем на ссылки base, start и index чтобы увидеть результат

step_7.1 - больше изменяемых блоков
    templates/base.html:
        + блок head - служебная информация для подключения стилей и т.п. внутри тега head
        + блок header - заголовок страницы (для добавления дополнительных элементов) внутри тега header
        + блок nav - ссылка "на главную" из содержимого тега header из day-1
        + блок footer - подвал сайта внутри тега footer
    templates/*:
        - удаляем все, что вне тега main
        + указываем, что текущий шаблон расширяет базовый
        + содержимое тега main переопределяет блок content
    templates/photo-{1, 2, 3}.html:
        + блок nav должен быть переопределен ссылкой на day-15
    templates/start.html:
        + блок nav должен быть переопределен пустотой

step_8 (В РАЗРАБОТКЕ)
    + templates/form.html:
        + расширяет базовый шаблон
        + переопределяет блок content
        + в качестве содержимого копируем форму из курса Великий Кексби на HTMLAcademy
        + в теге form меняем атрибут action на url_for('form')
    server:
        + декоратор пути /form
        + функция form, которая возвращает отрисованный шаблон form.html
        + в функции hello добавляем ссылку на форму
        ПРОВЕРКА: пройти по ссылке, попробовать заполнить форму и нажать кнопку "Отправить"
        ПРОБЛЕМА: ошибка при отправке формы
        + в декораторе пути для функции form добавляем параметр methods, в котором разрешаем GET и POST запросы
        + импортируем объект request, который ловит параметры каждого конкретного запроса
        + в функции form проверяем метод запроса, и если это POST-запрос, распечатываем данные формы (request.form)
        ПРОВЕРКА: попробовать заполнить поля формы и нажать на кнопку отправить. Посмотреть, что произошло на сервере.
        Можно увидеть распечатанный словарь, где ключами являются значения атрибутов name тегов input из формы

step_8.1 - стили для формы
    templates/form.html:
        + переопределяем блок head, подключая в нем еще один файл стилей - form-style.css (выделить из курса Великий Кексби)

step_9 - реакция на отправленную форму
    ПРОБЛЕМА: при отправке формы происходит открытие той же самой страницы с пустой формой. Непонятно, отправлена она или нет.
    Чтобы отправлять мгновенные реакции, во Flask есть функции flash и get_flashed_messages
    server:
        +
        + в функции form добавляем проверку на длину полного имени (или любую другую):
            если проверка пройдена, записываем мгновенное сообщение об успехе - flash('Обращение принято')
            если проверка НЕ пройдена, записываем мгновенное сообщение об отказе - flash('Вы допустили ошибку')
    templates/form.html:
        + перед тегом form добавляем цикл на языке Jinja2:
            {% for msg in get_flash_messages() %}
            <div class="flash">{{ msg }}</div>
            {% endfor %}
    ПРОВЕРКА: попробовать отправить форму, удовлетворяющую условию и неудовлетворяющую. Обновить страницу несколько раз
    ПРОБЛЕМА: для работы session, куда отправляет сообщения функция flash, нужен секретный ключ. Его нужно задать
    server:
        + app.config['SECRET_KEY'] = '<здесь символы, из которых состоит ключ>'


step_10 (В РАЗРАБОТКЕ)
    Авторизация. Использование session

step_20 (В РАЗРАБОТКЕ)
    Использование библиотеки flask-wtf для форм
